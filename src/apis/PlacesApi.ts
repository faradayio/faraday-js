/* tslint:disable */
/* eslint-disable */
/**
 * Faraday REST API
 * The [Faraday](https://faraday.ai) API makes it easy to predict customer behavior programmatically.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@faraday.ai
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    ArchiveConfig,
    Place,
    PlaceMergePatch,
    PlacePost,
} from '../models';

export interface ArchivePlaceRequest {
    placeId: string;
    archiveConfig: ArchiveConfig;
}

export interface CreatePlaceRequest {
    placeFields: PlacePost;
}

export interface DeletePlaceRequest {
    placeId: string;
}

export interface ForceUpdatePlaceRequest {
    placeId: string;
}

export interface GetPlaceRequest {
    placeId: string;
}

export interface UnarchivePlaceRequest {
    placeId: string;
    archiveConfig: ArchiveConfig;
}

export interface UpdatePlaceRequest {
    placeId: string;
    placeFields: PlaceMergePatch;
}

/**
 * 
 */
export class PlacesApi extends runtime.BaseAPI {

    /**
     * Archive a place
     * Archive a place
     */
    private async archivePlaceRaw(requestParameters: ArchivePlaceRequest, ): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.placeId === null || requestParameters.placeId === undefined) {
            throw new runtime.RequiredError('placeId','Required parameter requestParameters.placeId was null or undefined when calling archivePlace.');
        }

        if (requestParameters.archiveConfig === null || requestParameters.archiveConfig === undefined) {
            throw new runtime.RequiredError('archiveConfig','Required parameter requestParameters.archiveConfig was null or undefined when calling archivePlace.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/places/{place_id}/archive`.replace(`{${"place_id"}}`, encodeURIComponent(String(requestParameters.placeId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.archiveConfig,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Archive a place
     * Archive a place
     */
    async archivePlace(placeId: string, archiveConfig: ArchiveConfig, ): Promise<void> {
        await this.archivePlaceRaw({ placeId: placeId, archiveConfig: archiveConfig }, );
    }

    /**
     * Create a new place
     * Create place
     */
    private async createPlaceRaw(requestParameters: CreatePlaceRequest, ): Promise<runtime.ApiResponse<Place>> {
        if (requestParameters.placeFields === null || requestParameters.placeFields === undefined) {
            throw new runtime.RequiredError('placeFields','Required parameter requestParameters.placeFields was null or undefined when calling createPlace.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/places`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.placeFields,
        });

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create a new place
     * Create place
     */
    async createPlace(placeFields: PlacePost, ): Promise<Place> {
        const response = await this.createPlaceRaw({ placeFields: placeFields }, );
        return await response.value();
    }

    /**
     * Delete a place
     */
    private async deletePlaceRaw(requestParameters: DeletePlaceRequest, ): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.placeId === null || requestParameters.placeId === undefined) {
            throw new runtime.RequiredError('placeId','Required parameter requestParameters.placeId was null or undefined when calling deletePlace.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/places/{place_id}`.replace(`{${"place_id"}}`, encodeURIComponent(String(requestParameters.placeId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a place
     */
    async deletePlace(placeId: string, ): Promise<void> {
        await this.deletePlaceRaw({ placeId: placeId }, );
    }

    /**
     * Trigger a rerun for this resource. Faraday automatically updates resources when their config changes, but this option is available in case of transient errors. 
     * Trigger a rerun for this resource.
     */
    private async forceUpdatePlaceRaw(requestParameters: ForceUpdatePlaceRequest, ): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.placeId === null || requestParameters.placeId === undefined) {
            throw new runtime.RequiredError('placeId','Required parameter requestParameters.placeId was null or undefined when calling forceUpdatePlace.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/places/{place_id}/force_update`.replace(`{${"place_id"}}`, encodeURIComponent(String(requestParameters.placeId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Trigger a rerun for this resource. Faraday automatically updates resources when their config changes, but this option is available in case of transient errors. 
     * Trigger a rerun for this resource.
     */
    async forceUpdatePlace(placeId: string, ): Promise<void> {
        await this.forceUpdatePlaceRaw({ placeId: placeId }, );
    }

    /**
     * Retrieve details on a specific place
     * Retrieve a place
     */
    private async getPlaceRaw(requestParameters: GetPlaceRequest, ): Promise<runtime.ApiResponse<Place>> {
        if (requestParameters.placeId === null || requestParameters.placeId === undefined) {
            throw new runtime.RequiredError('placeId','Required parameter requestParameters.placeId was null or undefined when calling getPlace.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/places/{place_id}`.replace(`{${"place_id"}}`, encodeURIComponent(String(requestParameters.placeId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve details on a specific place
     * Retrieve a place
     */
    async getPlace(placeId: string, ): Promise<Place> {
        const response = await this.getPlaceRaw({ placeId: placeId }, );
        return await response.value();
    }

    /**
     * Get a list of the places available in the developerâ€™s account. Geometry and addresses are omitted from this endpoint\'s response to avoid overly large response sizes. If you want to inspect a place\'s geometry or addresses, then use GET /places/<place id>. 
     * List places
     */
    private async getPlacesRaw(): Promise<runtime.ApiResponse<Array<Place>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/places`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get a list of the places available in the developerâ€™s account. Geometry and addresses are omitted from this endpoint\'s response to avoid overly large response sizes. If you want to inspect a place\'s geometry or addresses, then use GET /places/<place id>. 
     * List places
     */
    async getPlaces(): Promise<Array<Place>> {
        const response = await this.getPlacesRaw();
        return await response.value();
    }

    /**
     * Unarchive a place
     * Unarchive a place
     */
    private async unarchivePlaceRaw(requestParameters: UnarchivePlaceRequest, ): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.placeId === null || requestParameters.placeId === undefined) {
            throw new runtime.RequiredError('placeId','Required parameter requestParameters.placeId was null or undefined when calling unarchivePlace.');
        }

        if (requestParameters.archiveConfig === null || requestParameters.archiveConfig === undefined) {
            throw new runtime.RequiredError('archiveConfig','Required parameter requestParameters.archiveConfig was null or undefined when calling unarchivePlace.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/places/{place_id}/unarchive`.replace(`{${"place_id"}}`, encodeURIComponent(String(requestParameters.placeId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.archiveConfig,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Unarchive a place
     * Unarchive a place
     */
    async unarchivePlace(placeId: string, archiveConfig: ArchiveConfig, ): Promise<void> {
        await this.unarchivePlaceRaw({ placeId: placeId, archiveConfig: archiveConfig }, );
    }

    /**
     * Update an existing place
     * Update place
     */
    private async updatePlaceRaw(requestParameters: UpdatePlaceRequest, ): Promise<runtime.ApiResponse<Place>> {
        if (requestParameters.placeId === null || requestParameters.placeId === undefined) {
            throw new runtime.RequiredError('placeId','Required parameter requestParameters.placeId was null or undefined when calling updatePlace.');
        }

        if (requestParameters.placeFields === null || requestParameters.placeFields === undefined) {
            throw new runtime.RequiredError('placeFields','Required parameter requestParameters.placeFields was null or undefined when calling updatePlace.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json+merge-patch';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/places/{place_id}`.replace(`{${"place_id"}}`, encodeURIComponent(String(requestParameters.placeId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.placeFields,
        });

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update an existing place
     * Update place
     */
    async updatePlace(placeId: string, placeFields: PlaceMergePatch, ): Promise<Place> {
        const response = await this.updatePlaceRaw({ placeId: placeId, placeFields: placeFields }, );
        return await response.value();
    }

}
