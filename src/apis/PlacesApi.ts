/* tslint:disable */
/* eslint-disable */
/**
 * Faraday REST API
 * The [Faraday](https://faraday.ai) API makes it easy to predict customer behavior programmatically.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@faraday.ai
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    Place,
    PlaceFromJSON,
    PlaceToJSON,
    PlaceMergePatch,
    PlaceMergePatchFromJSON,
    PlaceMergePatchToJSON,
    PlacePost,
    PlacePostFromJSON,
    PlacePostToJSON,
} from '../models';

export interface CreatePlaceRequest {
    placeFields: PlacePost;
}

export interface DeletePlaceRequest {
    placeId: string;
}

export interface GetPlaceRequest {
    placeId: string;
}

export interface UpdatePlaceRequest {
    placeId: string;
    placeFields: PlaceMergePatch;
}

/**
 * 
 */
export class PlacesApi extends runtime.BaseAPI {

    /**
     * Create a new place
     * Create place
     */
    private async createPlaceRaw(requestParameters: CreatePlaceRequest, ): Promise<runtime.ApiResponse<Place>> {
        if (requestParameters.placeFields === null || requestParameters.placeFields === undefined) {
            throw new runtime.RequiredError('placeFields','Required parameter requestParameters.placeFields was null or undefined when calling createPlace.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/places`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PlacePostToJSON(requestParameters.placeFields),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PlaceFromJSON(jsonValue));
    }

    /**
     * Create a new place
     * Create place
     */
    async createPlace(placeFields: PlacePost, ): Promise<Place> {
        const response = await this.createPlaceRaw({ placeFields: placeFields }, );
        return await response.value();
    }

    /**
     * Delete a place
     */
    private async deletePlaceRaw(requestParameters: DeletePlaceRequest, ): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.placeId === null || requestParameters.placeId === undefined) {
            throw new runtime.RequiredError('placeId','Required parameter requestParameters.placeId was null or undefined when calling deletePlace.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/places/{place_id}`.replace(`{${"place_id"}}`, encodeURIComponent(String(requestParameters.placeId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a place
     */
    async deletePlace(placeId: string, ): Promise<void> {
        await this.deletePlaceRaw({ placeId: placeId }, );
    }

    /**
     * Retrieve details on a specific place
     * Retrieve a place
     */
    private async getPlaceRaw(requestParameters: GetPlaceRequest, ): Promise<runtime.ApiResponse<Place>> {
        if (requestParameters.placeId === null || requestParameters.placeId === undefined) {
            throw new runtime.RequiredError('placeId','Required parameter requestParameters.placeId was null or undefined when calling getPlace.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/places/{place_id}`.replace(`{${"place_id"}}`, encodeURIComponent(String(requestParameters.placeId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PlaceFromJSON(jsonValue));
    }

    /**
     * Retrieve details on a specific place
     * Retrieve a place
     */
    async getPlace(placeId: string, ): Promise<Place> {
        const response = await this.getPlaceRaw({ placeId: placeId }, );
        return await response.value();
    }

    /**
     * Get a list of the places available in the developer’s account. Geometry and addresses are omitted from this endpoint\'s response to avoid overly large response sizes. If you want to inspect a place\'s geometry or addresses, then use GET /places/<place id>. 
     * List places
     */
    private async getPlacesRaw(): Promise<runtime.ApiResponse<Array<Place>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/places`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PlaceFromJSON));
    }

    /**
     * Get a list of the places available in the developer’s account. Geometry and addresses are omitted from this endpoint\'s response to avoid overly large response sizes. If you want to inspect a place\'s geometry or addresses, then use GET /places/<place id>. 
     * List places
     */
    async getPlaces(): Promise<Array<Place>> {
        const response = await this.getPlacesRaw();
        return await response.value();
    }

    /**
     * Update an existing place
     * Update place
     */
    private async updatePlaceRaw(requestParameters: UpdatePlaceRequest, ): Promise<runtime.ApiResponse<Place>> {
        if (requestParameters.placeId === null || requestParameters.placeId === undefined) {
            throw new runtime.RequiredError('placeId','Required parameter requestParameters.placeId was null or undefined when calling updatePlace.');
        }

        if (requestParameters.placeFields === null || requestParameters.placeFields === undefined) {
            throw new runtime.RequiredError('placeFields','Required parameter requestParameters.placeFields was null or undefined when calling updatePlace.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json+merge-patch';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/places/{place_id}`.replace(`{${"place_id"}}`, encodeURIComponent(String(requestParameters.placeId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PlaceMergePatchToJSON(requestParameters.placeFields),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PlaceFromJSON(jsonValue));
    }

    /**
     * Update an existing place
     * Update place
     */
    async updatePlace(placeId: string, placeFields: PlaceMergePatch, ): Promise<Place> {
        const response = await this.updatePlaceRaw({ placeId: placeId, placeFields: placeFields }, );
        return await response.value();
    }

}
