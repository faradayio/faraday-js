/* tslint:disable */
/* eslint-disable */
/**
 * Faraday REST API
 * The [Faraday](https://faraday.ai) API makes it easy to predict customer behavior programmatically. See our [API change policy](https://faraday.ai/legal).
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@faraday.ai
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    FeatureStore,
    FeatureStoreMergePatch,
    FeatureStorePost,
} from '../models';

export interface CreateFeatureStoreRequest {
    featureStorePost: FeatureStorePost;
}

export interface DeleteFeatureStoreRequest {
    featureStoreId: string;
}

export interface ForceUpdateFeatureStoreRequest {
    featureStoreId: string;
}

export interface GetFeatureStoreRequest {
    featureStoreId: string;
}

export interface GetFeatureStoresRequest {
    ids?: Array<string>;
}

export interface UpdateFeatureStoreRequest {
    featureStoreId: string;
    featureStoreFields: FeatureStoreMergePatch;
}

/**
 * 
 */
export class FeatureStoresApi extends runtime.BaseAPI {

    /**
     * Add a new feature store that compiles attributes
     * Create feature store
     */
    async createFeatureStoreRaw(requestParameters: CreateFeatureStoreRequest, ): Promise<runtime.ApiResponse<FeatureStore>> {
        if (requestParameters.featureStorePost === null || requestParameters.featureStorePost === undefined) {
            throw new runtime.RequiredError('featureStorePost','Required parameter requestParameters.featureStorePost was null or undefined when calling createFeatureStore.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/feature_stores`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.featureStorePost,
        });

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Add a new feature store that compiles attributes
     * Create feature store
     */
    async createFeatureStore(featureStorePost: FeatureStorePost, ): Promise<FeatureStore> {
        const response = await this.createFeatureStoreRaw({ featureStorePost: featureStorePost }, );
        return await response.value();
    }

    /**
     * Delete a feature store
     */
    async deleteFeatureStoreRaw(requestParameters: DeleteFeatureStoreRequest, ): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.featureStoreId === null || requestParameters.featureStoreId === undefined) {
            throw new runtime.RequiredError('featureStoreId','Required parameter requestParameters.featureStoreId was null or undefined when calling deleteFeatureStore.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/feature_stores/{feature_store_id}`.replace(`{${"feature_store_id"}}`, encodeURIComponent(String(requestParameters.featureStoreId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a feature store
     */
    async deleteFeatureStore(featureStoreId: string, ): Promise<void> {
        await this.deleteFeatureStoreRaw({ featureStoreId: featureStoreId }, );
    }

    /**
     * Trigger a rerun for this resource. Faraday automatically updates resources when their config changes, but this option is available in case of transient errors. 
     * Trigger a rerun for this resource.
     */
    async forceUpdateFeatureStoreRaw(requestParameters: ForceUpdateFeatureStoreRequest, ): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.featureStoreId === null || requestParameters.featureStoreId === undefined) {
            throw new runtime.RequiredError('featureStoreId','Required parameter requestParameters.featureStoreId was null or undefined when calling forceUpdateFeatureStore.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/feature_stores/{feature_store_id}/force_update`.replace(`{${"feature_store_id"}}`, encodeURIComponent(String(requestParameters.featureStoreId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Trigger a rerun for this resource. Faraday automatically updates resources when their config changes, but this option is available in case of transient errors. 
     * Trigger a rerun for this resource.
     */
    async forceUpdateFeatureStore(featureStoreId: string, ): Promise<void> {
        await this.forceUpdateFeatureStoreRaw({ featureStoreId: featureStoreId }, );
    }

    /**
     * Get details on a specific feature store
     * Retrieve a feature store
     */
    async getFeatureStoreRaw(requestParameters: GetFeatureStoreRequest, ): Promise<runtime.ApiResponse<FeatureStore>> {
        if (requestParameters.featureStoreId === null || requestParameters.featureStoreId === undefined) {
            throw new runtime.RequiredError('featureStoreId','Required parameter requestParameters.featureStoreId was null or undefined when calling getFeatureStore.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/feature_stores/{feature_store_id}`.replace(`{${"feature_store_id"}}`, encodeURIComponent(String(requestParameters.featureStoreId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get details on a specific feature store
     * Retrieve a feature store
     */
    async getFeatureStore(featureStoreId: string, ): Promise<FeatureStore> {
        const response = await this.getFeatureStoreRaw({ featureStoreId: featureStoreId }, );
        return await response.value();
    }

    /**
     * Get a list of feature stores defined on the account
     * List feature stores
     */
    async getFeatureStoresRaw(requestParameters: GetFeatureStoresRequest, ): Promise<runtime.ApiResponse<Array<FeatureStore>>> {
        const queryParameters: any = {};

        if (requestParameters.ids) {
            queryParameters['ids'] = requestParameters.ids;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/feature_stores`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get a list of feature stores defined on the account
     * List feature stores
     */
    async getFeatureStores(ids?: Array<string>, ): Promise<Array<FeatureStore>> {
        const response = await this.getFeatureStoresRaw({ ids: ids }, );
        return await response.value();
    }

    /**
     * Update the configuration of a feature store
     * Update a feature store
     */
    async updateFeatureStoreRaw(requestParameters: UpdateFeatureStoreRequest, ): Promise<runtime.ApiResponse<FeatureStore>> {
        if (requestParameters.featureStoreId === null || requestParameters.featureStoreId === undefined) {
            throw new runtime.RequiredError('featureStoreId','Required parameter requestParameters.featureStoreId was null or undefined when calling updateFeatureStore.');
        }

        if (requestParameters.featureStoreFields === null || requestParameters.featureStoreFields === undefined) {
            throw new runtime.RequiredError('featureStoreFields','Required parameter requestParameters.featureStoreFields was null or undefined when calling updateFeatureStore.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json+merge-patch';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/feature_stores/{feature_store_id}`.replace(`{${"feature_store_id"}}`, encodeURIComponent(String(requestParameters.featureStoreId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.featureStoreFields,
        });

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update the configuration of a feature store
     * Update a feature store
     */
    async updateFeatureStore(featureStoreId: string, featureStoreFields: FeatureStoreMergePatch, ): Promise<FeatureStore> {
        const response = await this.updateFeatureStoreRaw({ featureStoreId: featureStoreId, featureStoreFields: featureStoreFields }, );
        return await response.value();
    }

}
