/* tslint:disable */
/* eslint-disable */
/**
 * Faraday REST API
 * The [Faraday](https://faraday.ai) API makes it easy to predict customer behavior programmatically.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@faraday.ai
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    ArchiveConfig,
    Dataset,
    DatasetMergePatch,
    DatasetPost,
} from '../models';

export interface ArchiveDatasetRequest {
    datasetId: string;
    archiveConfig: ArchiveConfig;
}

export interface CreateDatasetRequest {
    datasetFields: DatasetPost;
}

export interface DeleteDatasetRequest {
    datasetId: string;
}

export interface ForceUpdateDatasetRequest {
    datasetId: string;
}

export interface GetDatasetRequest {
    datasetId: string;
}

export interface UnarchiveDatasetRequest {
    datasetId: string;
    archiveConfig: ArchiveConfig;
}

export interface UpdateDatasetRequest {
    datasetId: string;
    datasetFields: DatasetMergePatch;
}

/**
 * 
 */
export class DatasetsApi extends runtime.BaseAPI {

    /**
     * Archive a dataset
     * Archive a dataset
     */
    private async archiveDatasetRaw(requestParameters: ArchiveDatasetRequest, ): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.datasetId === null || requestParameters.datasetId === undefined) {
            throw new runtime.RequiredError('datasetId','Required parameter requestParameters.datasetId was null or undefined when calling archiveDataset.');
        }

        if (requestParameters.archiveConfig === null || requestParameters.archiveConfig === undefined) {
            throw new runtime.RequiredError('archiveConfig','Required parameter requestParameters.archiveConfig was null or undefined when calling archiveDataset.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/datasets/{dataset_id}/archive`.replace(`{${"dataset_id"}}`, encodeURIComponent(String(requestParameters.datasetId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.archiveConfig,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Archive a dataset
     * Archive a dataset
     */
    async archiveDataset(datasetId: string, archiveConfig: ArchiveConfig, ): Promise<void> {
        await this.archiveDatasetRaw({ datasetId: datasetId, archiveConfig: archiveConfig }, );
    }

    /**
     * Create a new dataset
     * Create dataset
     */
    private async createDatasetRaw(requestParameters: CreateDatasetRequest, ): Promise<runtime.ApiResponse<Dataset>> {
        if (requestParameters.datasetFields === null || requestParameters.datasetFields === undefined) {
            throw new runtime.RequiredError('datasetFields','Required parameter requestParameters.datasetFields was null or undefined when calling createDataset.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/datasets`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.datasetFields,
        });

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create a new dataset
     * Create dataset
     */
    async createDataset(datasetFields: DatasetPost, ): Promise<Dataset> {
        const response = await this.createDatasetRaw({ datasetFields: datasetFields }, );
        return await response.value();
    }

    /**
     * Delete a dataset
     */
    private async deleteDatasetRaw(requestParameters: DeleteDatasetRequest, ): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.datasetId === null || requestParameters.datasetId === undefined) {
            throw new runtime.RequiredError('datasetId','Required parameter requestParameters.datasetId was null or undefined when calling deleteDataset.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/datasets/{dataset_id}`.replace(`{${"dataset_id"}}`, encodeURIComponent(String(requestParameters.datasetId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a dataset
     */
    async deleteDataset(datasetId: string, ): Promise<void> {
        await this.deleteDatasetRaw({ datasetId: datasetId }, );
    }

    /**
     * Trigger a rerun for this resource. Faraday automatically updates resources when their config changes, but this option is available in case of transient errors. 
     * Trigger a rerun for this resource.
     */
    private async forceUpdateDatasetRaw(requestParameters: ForceUpdateDatasetRequest, ): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.datasetId === null || requestParameters.datasetId === undefined) {
            throw new runtime.RequiredError('datasetId','Required parameter requestParameters.datasetId was null or undefined when calling forceUpdateDataset.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/datasets/{dataset_id}/force_update`.replace(`{${"dataset_id"}}`, encodeURIComponent(String(requestParameters.datasetId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Trigger a rerun for this resource. Faraday automatically updates resources when their config changes, but this option is available in case of transient errors. 
     * Trigger a rerun for this resource.
     */
    async forceUpdateDataset(datasetId: string, ): Promise<void> {
        await this.forceUpdateDatasetRaw({ datasetId: datasetId }, );
    }

    /**
     * Retrieve details on a specific dataset
     * Retrieve a dataset
     */
    private async getDatasetRaw(requestParameters: GetDatasetRequest, ): Promise<runtime.ApiResponse<Dataset>> {
        if (requestParameters.datasetId === null || requestParameters.datasetId === undefined) {
            throw new runtime.RequiredError('datasetId','Required parameter requestParameters.datasetId was null or undefined when calling getDataset.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/datasets/{dataset_id}`.replace(`{${"dataset_id"}}`, encodeURIComponent(String(requestParameters.datasetId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve details on a specific dataset
     * Retrieve a dataset
     */
    async getDataset(datasetId: string, ): Promise<Dataset> {
        const response = await this.getDatasetRaw({ datasetId: datasetId }, );
        return await response.value();
    }

    /**
     * Get a list of the datasets available in the developerâ€™s account
     * List datasets
     */
    private async getDatasetsRaw(): Promise<runtime.ApiResponse<Array<Dataset>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/datasets`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get a list of the datasets available in the developerâ€™s account
     * List datasets
     */
    async getDatasets(): Promise<Array<Dataset>> {
        const response = await this.getDatasetsRaw();
        return await response.value();
    }

    /**
     * Unarchive a dataset
     * Unarchive a dataset
     */
    private async unarchiveDatasetRaw(requestParameters: UnarchiveDatasetRequest, ): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.datasetId === null || requestParameters.datasetId === undefined) {
            throw new runtime.RequiredError('datasetId','Required parameter requestParameters.datasetId was null or undefined when calling unarchiveDataset.');
        }

        if (requestParameters.archiveConfig === null || requestParameters.archiveConfig === undefined) {
            throw new runtime.RequiredError('archiveConfig','Required parameter requestParameters.archiveConfig was null or undefined when calling unarchiveDataset.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/datasets/{dataset_id}/unarchive`.replace(`{${"dataset_id"}}`, encodeURIComponent(String(requestParameters.datasetId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.archiveConfig,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Unarchive a dataset
     * Unarchive a dataset
     */
    async unarchiveDataset(datasetId: string, archiveConfig: ArchiveConfig, ): Promise<void> {
        await this.unarchiveDatasetRaw({ datasetId: datasetId, archiveConfig: archiveConfig }, );
    }

    /**
     * Update an existing dataset
     * Update dataset
     */
    private async updateDatasetRaw(requestParameters: UpdateDatasetRequest, ): Promise<runtime.ApiResponse<Dataset>> {
        if (requestParameters.datasetId === null || requestParameters.datasetId === undefined) {
            throw new runtime.RequiredError('datasetId','Required parameter requestParameters.datasetId was null or undefined when calling updateDataset.');
        }

        if (requestParameters.datasetFields === null || requestParameters.datasetFields === undefined) {
            throw new runtime.RequiredError('datasetFields','Required parameter requestParameters.datasetFields was null or undefined when calling updateDataset.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json+merge-patch';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/datasets/{dataset_id}`.replace(`{${"dataset_id"}}`, encodeURIComponent(String(requestParameters.datasetId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.datasetFields,
        });

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update an existing dataset
     * Update dataset
     */
    async updateDataset(datasetId: string, datasetFields: DatasetMergePatch, ): Promise<Dataset> {
        const response = await this.updateDatasetRaw({ datasetId: datasetId, datasetFields: datasetFields }, );
        return await response.value();
    }

}
