/* tslint:disable */
/* eslint-disable */
/**
 * Faraday REST API
 * The [Faraday](https://faraday.ai) API makes it easy to predict customer behavior programmatically. See our [API change policy](https://faraday.ai/legal).
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@faraday.ai
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    Attribute,
    AttributeMergePatch,
    AttributePost,
} from '../models';

export interface CreateAttributeRequest {
    attributePost: AttributePost;
}

export interface DeleteAttributeRequest {
    attributeId: string;
}

export interface ForceUpdateAttributeRequest {
    attributeId: string;
}

export interface GetAttributeRequest {
    attributeId: string;
}

export interface UpdateAttributeRequest {
    attributeId: string;
    attributeFields: AttributeMergePatch;
}

/**
 * 
 */
export class AttributesApi extends runtime.BaseAPI {

    /**
     * Add a new attribute that wraps a stream of assertions
     * Create attribute
     */
    private async createAttributeRaw(requestParameters: CreateAttributeRequest, ): Promise<runtime.ApiResponse<Attribute>> {
        if (requestParameters.attributePost === null || requestParameters.attributePost === undefined) {
            throw new runtime.RequiredError('attributePost','Required parameter requestParameters.attributePost was null or undefined when calling createAttribute.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/attributes`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.attributePost,
        });

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Add a new attribute that wraps a stream of assertions
     * Create attribute
     */
    async createAttribute(attributePost: AttributePost, ): Promise<Attribute> {
        const response = await this.createAttributeRaw({ attributePost: attributePost }, );
        return await response.value();
    }

    /**
     * Delete an attribute
     */
    private async deleteAttributeRaw(requestParameters: DeleteAttributeRequest, ): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.attributeId === null || requestParameters.attributeId === undefined) {
            throw new runtime.RequiredError('attributeId','Required parameter requestParameters.attributeId was null or undefined when calling deleteAttribute.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/attributes/{attribute_id}`.replace(`{${"attribute_id"}}`, encodeURIComponent(String(requestParameters.attributeId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete an attribute
     */
    async deleteAttribute(attributeId: string, ): Promise<void> {
        await this.deleteAttributeRaw({ attributeId: attributeId }, );
    }

    /**
     * Trigger a rerun for this resource. Faraday automatically updates resources when their config changes, but this option is available in case of transient errors. 
     * Trigger a rerun for this resource.
     */
    private async forceUpdateAttributeRaw(requestParameters: ForceUpdateAttributeRequest, ): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.attributeId === null || requestParameters.attributeId === undefined) {
            throw new runtime.RequiredError('attributeId','Required parameter requestParameters.attributeId was null or undefined when calling forceUpdateAttribute.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/attributes/{attribute_id}/force_update`.replace(`{${"attribute_id"}}`, encodeURIComponent(String(requestParameters.attributeId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Trigger a rerun for this resource. Faraday automatically updates resources when their config changes, but this option is available in case of transient errors. 
     * Trigger a rerun for this resource.
     */
    async forceUpdateAttribute(attributeId: string, ): Promise<void> {
        await this.forceUpdateAttributeRaw({ attributeId: attributeId }, );
    }

    /**
     * Get details on a specific attribute
     * Retrieve an attribute
     */
    private async getAttributeRaw(requestParameters: GetAttributeRequest, ): Promise<runtime.ApiResponse<Attribute>> {
        if (requestParameters.attributeId === null || requestParameters.attributeId === undefined) {
            throw new runtime.RequiredError('attributeId','Required parameter requestParameters.attributeId was null or undefined when calling getAttribute.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/attributes/{attribute_id}`.replace(`{${"attribute_id"}}`, encodeURIComponent(String(requestParameters.attributeId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get details on a specific attribute
     * Retrieve an attribute
     */
    async getAttribute(attributeId: string, ): Promise<Attribute> {
        const response = await this.getAttributeRaw({ attributeId: attributeId }, );
        return await response.value();
    }

    /**
     * Get a list of attributes defined on the account
     * List attributes
     */
    private async getAttributesRaw(): Promise<runtime.ApiResponse<Array<Attribute>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/attributes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get a list of attributes defined on the account
     * List attributes
     */
    async getAttributes(): Promise<Array<Attribute>> {
        const response = await this.getAttributesRaw();
        return await response.value();
    }

    /**
     * Update the configuration of an attribute
     * Update an attribute
     */
    private async updateAttributeRaw(requestParameters: UpdateAttributeRequest, ): Promise<runtime.ApiResponse<Attribute>> {
        if (requestParameters.attributeId === null || requestParameters.attributeId === undefined) {
            throw new runtime.RequiredError('attributeId','Required parameter requestParameters.attributeId was null or undefined when calling updateAttribute.');
        }

        if (requestParameters.attributeFields === null || requestParameters.attributeFields === undefined) {
            throw new runtime.RequiredError('attributeFields','Required parameter requestParameters.attributeFields was null or undefined when calling updateAttribute.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json+merge-patch';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/attributes/{attribute_id}`.replace(`{${"attribute_id"}}`, encodeURIComponent(String(requestParameters.attributeId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.attributeFields,
        });

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update the configuration of an attribute
     * Update an attribute
     */
    async updateAttribute(attributeId: string, attributeFields: AttributeMergePatch, ): Promise<Attribute> {
        const response = await this.updateAttributeRaw({ attributeId: attributeId, attributeFields: attributeFields }, );
        return await response.value();
    }

}
